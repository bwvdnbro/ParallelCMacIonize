DensitySubGrid:

Data:
(for index computations)
double _anchor[3]
double _inv_cell_size[3]

(for cell index computation)
unsigned int _cellsize[4] = {num cell x, num cell y, num cell z, num cell y * num cell z}

(for cell variable storage)
Variables _cells[num cell x * num cell y * num cell z]

Methods:
PRIVATE
(convert 3-index to 1-index)
unsigned short? get_one_index(char? three_index[3]){
  return three_index[0] * _cellsize[3] + three_index[1] * _cellsize[2] + three_index[2]
}

(check if the given index is inside the subgrid)
bool is_inside(const char *three_index){
  return three_index[0] < _cellsize[0] && three_index[0] >= 0 ...
}

(get the index of the cell containing a certain position, using prior knowledge of entry point if available)
(*NOTE that we can refine this method later and start from a more general one*)
unsigned short? get_start_index(double position[3], INPUT_DIRECTION, char*? three_index[3]){
  // IGNORE INPUT_DIRECTION
  three_index[0] = (position[0] - _anchor[0]) * _inv_cell_size[0]
  ...
  ASSERT(is_inside(three_index))
  return get_one_index(three_index)
}

OUTPUT_DIRECTION get_output_direction(const char* three_index[3]){
  // get negative or too large indices and convert into one of 26 possible neighbour outputs
}

PUBLIC
(propagate a single photon through the grid)
OUTPUT_DIRECTION propagate_photon(Photon photon, INPUT_DIRECTION){
  const double direction[3] = photon.get_direction();
  double position[3] = photon.get_position();
  double tau_done = photon.get_current_optical_depth();
  const double tau_target = photon.get_target_optical_depth();
  unsigned char? three_index[3];
  get_start_index(position, INPUT_DIRECTION, three_index);
  // enter while loop. QUESTION: what is condition?
  // double condition:
  //  - target optical depth not reached (tau_done < tau_target)
  //  - photon still in subgrid: is_inside(three_index)
  while(tau_done < tau_target && is_inside){
    // magic
  }
  if(tau_done >= target){
    // correct extra
    // output direction = ABSORBED
  }
  if(!is_inside(three_index)){
    return get_output_direction(three_index)
  }
}
